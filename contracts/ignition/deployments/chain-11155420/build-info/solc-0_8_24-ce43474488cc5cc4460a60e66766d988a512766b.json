{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-ce43474488cc5cc4460a60e66766d988a512766b",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/EIP7702AuthorizedCode.sol": "project/contracts/EIP7702AuthorizedCode.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/EIP7702AuthorizedCode.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/**\r\n * @title EIP7702AuthorizedCode\r\n * @dev This contract serves as the authorized code for EIP-7702 account delegation\r\n * It can be installed into EOAs to enable delegation functionality\r\n */\r\ncontract EIP7702AuthorizedCode {\r\n    // Storage slot for delegation manager address\r\n    bytes32 private constant DELEGATION_MANAGER_SLOT =\r\n        keccak256(\"eip7702.delegation.manager\");\r\n\r\n    // Storage slot for owner address (original EOA owner)\r\n    bytes32 private constant OWNER_SLOT = keccak256(\"eip7702.delegation.owner\");\r\n\r\n    event DelegationManagerSet(address indexed manager);\r\n    event OwnerSet(address indexed owner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == getOwner(), \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize the authorized code with delegation manager and owner\r\n     * @param delegationManager Address of the delegation manager contract\r\n     * @param owner Original EOA owner address\r\n     */\r\n    function initialize(address delegationManager, address owner) external {\r\n        require(getDelegationManager() == address(0), \"Already initialized\");\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n        require(owner != address(0), \"Invalid owner\");\r\n\r\n        _setDelegationManager(delegationManager);\r\n        _setOwner(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute a delegated transaction\r\n     * @param target Target contract address\r\n     * @param data Transaction data\r\n     * @param value ETH value to send\r\n     */\r\n    function executeDelegatedCall(\r\n        address target,\r\n        bytes calldata data,\r\n        uint256 value\r\n    ) external onlyOwner returns (bool success, bytes memory returnData) {\r\n        require(target != address(0), \"Invalid target\");\r\n\r\n        // Execute the call\r\n        (success, returnData) = target.call{value: value}(data);\r\n\r\n        return (success, returnData);\r\n    }\r\n\r\n    /**\r\n     * @dev Batch execute multiple delegated transactions\r\n     * @param targets Array of target contract addresses\r\n     * @param datas Array of transaction data\r\n     * @param values Array of ETH values to send\r\n     */\r\n    function batchExecuteDelegatedCalls(\r\n        address[] calldata targets,\r\n        bytes[] calldata datas,\r\n        uint256[] calldata values\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (bool[] memory successes, bytes[] memory returnDatas)\r\n    {\r\n        require(\r\n            targets.length == datas.length && datas.length == values.length,\r\n            \"Array length mismatch\"\r\n        );\r\n\r\n        successes = new bool[](targets.length);\r\n        returnDatas = new bytes[](targets.length);\r\n\r\n        for (uint256 i = 0; i < targets.length; i++) {\r\n            (successes[i], returnDatas[i]) = targets[i].call{value: values[i]}(\r\n                datas[i]\r\n            );\r\n        }\r\n\r\n        return (successes, returnDatas);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ETH from this account\r\n     * @param to Recipient address\r\n     * @param amount Amount to transfer\r\n     */\r\n    function transferETH(\r\n        address payable to,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        require(to != address(0), \"Invalid recipient\");\r\n        require(address(this).balance >= amount, \"Insufficient balance\");\r\n\r\n        (bool success, ) = to.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ERC20 tokens from this account\r\n     * @param token Token contract address\r\n     * @param to Recipient address\r\n     * @param amount Amount to transfer\r\n     */\r\n    function transferERC20(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        require(token != address(0), \"Invalid token\");\r\n        require(to != address(0), \"Invalid recipient\");\r\n\r\n        // Call transfer function on token contract\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount)\r\n        );\r\n\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"Transfer failed\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Approve ERC20 token spending\r\n     * @param token Token contract address\r\n     * @param spender Spender address\r\n     * @param amount Amount to approve\r\n     */\r\n    function approveERC20(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        require(token != address(0), \"Invalid token\");\r\n        require(spender != address(0), \"Invalid spender\");\r\n\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\r\n        );\r\n\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"Approval failed\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Create a subscription via the delegation manager\r\n     * @param delegationManager Address of the delegation manager\r\n     * @param recipient Address to receive recurring payments\r\n     * @param token Token contract address (address(0) for ETH)\r\n     * @param amountPerInterval Amount to transfer each interval\r\n     * @param totalAmount Total amount to deposit\r\n     * @param startTime When the subscription should start\r\n     * @param interval Payment interval in seconds\r\n     * @param periods Total number of payment periods\r\n     */\r\n    function createSubscription(\r\n        address delegationManager,\r\n        address recipient,\r\n        address token,\r\n        uint256 amountPerInterval,\r\n        uint256 totalAmount,\r\n        uint256 startTime,\r\n        uint256 interval,\r\n        uint256 periods\r\n    ) external onlyOwner {\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n        require(recipient != address(0), \"Invalid recipient\");\r\n        require(\r\n            totalAmount == amountPerInterval * periods,\r\n            \"Total amount mismatch\"\r\n        );\r\n\r\n        if (token == address(0)) {\r\n            // ETH subscription\r\n            require(\r\n                address(this).balance >= totalAmount,\r\n                \"Insufficient ETH balance\"\r\n            );\r\n\r\n            (bool success, ) = delegationManager.call{value: totalAmount}(\r\n                abi.encodeWithSignature(\r\n                    \"createSubscription(address,address,uint256,uint256,uint256,uint256,uint256)\",\r\n                    recipient,\r\n                    token,\r\n                    amountPerInterval,\r\n                    totalAmount,\r\n                    startTime,\r\n                    interval,\r\n                    periods\r\n                )\r\n            );\r\n            require(success, \"Subscription creation failed\");\r\n        } else {\r\n            // ERC20 subscription - first approve, then create\r\n            (bool approveSuccess, bytes memory approveData) = token.call(\r\n                abi.encodeWithSignature(\r\n                    \"approve(address,uint256)\",\r\n                    delegationManager,\r\n                    totalAmount\r\n                )\r\n            );\r\n            require(\r\n                approveSuccess &&\r\n                    (approveData.length == 0 ||\r\n                        abi.decode(approveData, (bool))),\r\n                \"Token approval failed\"\r\n            );\r\n\r\n            (bool success, ) = delegationManager.call(\r\n                abi.encodeWithSignature(\r\n                    \"createSubscription(address,address,uint256,uint256,uint256,uint256,uint256)\",\r\n                    recipient,\r\n                    token,\r\n                    amountPerInterval,\r\n                    totalAmount,\r\n                    startTime,\r\n                    interval,\r\n                    periods\r\n                )\r\n            );\r\n            require(success, \"Subscription creation failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel a subscription via the delegation manager\r\n     * @param delegationManager Address of the delegation manager\r\n     * @param subscriptionId ID of the subscription to cancel\r\n     */\r\n    function cancelSubscription(\r\n        address delegationManager,\r\n        uint256 subscriptionId\r\n    ) external onlyOwner {\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n\r\n        (bool success, ) = delegationManager.call(\r\n            abi.encodeWithSignature(\r\n                \"cancelSubscription(uint256)\",\r\n                subscriptionId\r\n            )\r\n        );\r\n        require(success, \"Subscription cancellation failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Pause a subscription via the delegation manager\r\n     * @param delegationManager Address of the delegation manager\r\n     * @param subscriptionId ID of the subscription to pause\r\n     */\r\n    function pauseSubscription(\r\n        address delegationManager,\r\n        uint256 subscriptionId\r\n    ) external onlyOwner {\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n\r\n        (bool success, ) = delegationManager.call(\r\n            abi.encodeWithSignature(\r\n                \"pauseSubscription(uint256)\",\r\n                subscriptionId\r\n            )\r\n        );\r\n        require(success, \"Subscription pause failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Resume a subscription via the delegation manager\r\n     * @param delegationManager Address of the delegation manager\r\n     * @param subscriptionId ID of the subscription to resume\r\n     */\r\n    function resumeSubscription(\r\n        address delegationManager,\r\n        uint256 subscriptionId\r\n    ) external onlyOwner {\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n\r\n        (bool success, ) = delegationManager.call(\r\n            abi.encodeWithSignature(\r\n                \"resumeSubscription(uint256)\",\r\n                subscriptionId\r\n            )\r\n        );\r\n        require(success, \"Subscription resume failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Process a subscription payment via the delegation manager\r\n     * @param delegationManager Address of the delegation manager\r\n     * @param subscriptionId ID of the subscription to process\r\n     */\r\n    function processSubscriptionPayment(\r\n        address delegationManager,\r\n        uint256 subscriptionId\r\n    ) external onlyOwner {\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n\r\n        (bool success, ) = delegationManager.call(\r\n            abi.encodeWithSignature(\r\n                \"processSubscriptionPayment(uint256)\",\r\n                subscriptionId\r\n            )\r\n        );\r\n        require(success, \"Subscription payment processing failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Get the delegation manager address\r\n     */\r\n    function getDelegationManager() public view returns (address) {\r\n        bytes32 slot = DELEGATION_MANAGER_SLOT;\r\n        address manager;\r\n        assembly {\r\n            manager := sload(slot)\r\n        }\r\n        return manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the owner address\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        bytes32 slot = OWNER_SLOT;\r\n        address owner;\r\n        assembly {\r\n            owner := sload(slot)\r\n        }\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the delegation manager address (internal)\r\n     */\r\n    function _setDelegationManager(address manager) internal {\r\n        bytes32 slot = DELEGATION_MANAGER_SLOT;\r\n        assembly {\r\n            sstore(slot, manager)\r\n        }\r\n        emit DelegationManagerSet(manager);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the owner address (internal)\r\n     */\r\n    function _setOwner(address owner) internal {\r\n        bytes32 slot = OWNER_SLOT;\r\n        assembly {\r\n            sstore(slot, owner)\r\n        }\r\n        emit OwnerSet(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to handle direct calls\r\n     */\r\n    fallback() external payable {\r\n        // For EIP-7702, this can be used to handle generic calls\r\n        // Implementation depends on specific use case\r\n    }\r\n\r\n    /**\r\n     * @dev Receive function to handle plain ETH transfers\r\n     */\r\n    receive() external payable {\r\n        // Allow receiving ETH\r\n    }\r\n\r\n    /**\r\n     * @dev Batch process multiple subscription payments\r\n     * @param delegationManager Address of the delegation manager\r\n     * @param subscriptionIds Array of subscription IDs to process\r\n     */\r\n    function batchProcessSubscriptionPayments(\r\n        address delegationManager,\r\n        uint256[] calldata subscriptionIds\r\n    ) external onlyOwner {\r\n        require(delegationManager != address(0), \"Invalid delegation manager\");\r\n\r\n        (bool success, ) = delegationManager.call(\r\n            abi.encodeWithSignature(\r\n                \"batchProcessSubscriptionPayments(uint256[])\",\r\n                subscriptionIds\r\n            )\r\n        );\r\n        require(success, \"Batch subscription processing failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Check if this contract supports an interface\r\n     * @param interfaceId Interface identifier\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) external pure returns (bool) {\r\n        // EIP-7702 interface support can be added here\r\n        return interfaceId == 0x01ffc9a7; // ERC165\r\n    }\r\n}\r\n"
      }
    }
  }
}